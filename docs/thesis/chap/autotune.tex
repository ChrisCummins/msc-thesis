\section{Introduction}

In this chapter we describe the design and implementation of OmniTune,
an extensible, dynamic autotuner. We evaluate the performance of
OmniTune when tasked with tuning workgroup size of stencil codes.


\section{Machine Learning and Performance Tuning}

\TODO{We're always dealing with a sparsity in data.}


\subsection{Feature Extraction}

For each scenario, a feature vector is extracted to capture properties
of the architecture, device, and dataset:

\begin{itemize}
\item \emph{Architectural features} --- size of local memory, maximum
  work group size, number of compute units, etc. Accessed using the
  OpenCL \texttt{clGetDeviceInfo()} API.
\item \emph{Kernel features} --- total static instruction count, ratio
  of instructions per type, ratio of basic blocks per instruction,
  etc. Accessed by compiling the OpenCL kernel to LLVM IR bitcode, and
  using the \texttt{opt} \texttt{InstCount} statistics pass.
\item \emph{Dataset features} --- size and type of the
  dataset. Accessed from the SkelCL Matrix container type.
\end{itemize}

See \FIXME{No appendix!} for a full list of features and types. For
training, feature vectors are labelled with the oracle workgroup size,
and a classifier is trained on a subset of this labelled training
data. The performance of the classifier is evaluated by comparing the
performance of the workgroup size predicted for an unseen feature
vector against the oracle workgroup size for that feature.

A full list of the feature names and types used to train machine
learning models. For training data, each feature vector was labelled
with the oracle workgroup size.

\begin{multicols}{2}
\begin{Verbatim}[fontsize=\footnotesize]
data_width                         numeric
data_height                        numeric
data_tin                           nominal
data_tout                          nominal
kern_north                         numeric
kern_south                         numeric
kern_east                          numeric
kern_west                          numeric
kern_max_wg_size                   numeric
kern_instruction_count             numeric
kern_ratio_AShr_insts              numeric
kern_ratio_Add_insts               numeric
kern_ratio_Alloca_insts            numeric
kern_ratio_And_insts               numeric
kern_ratio_Br_insts                numeric
kern_ratio_Call_insts              numeric
kern_ratio_FAdd_insts              numeric
kern_ratio_FCmp_insts              numeric
kern_ratio_FDiv_insts              numeric
kern_ratio_FMul_insts              numeric
kern_ratio_FPExt_insts             numeric
kern_ratio_FPToSI_insts            numeric
kern_ratio_FSub_insts              numeric
kern_ratio_GetElementPtr_insts     numeric
kern_ratio_ICmp_insts              numeric
kern_ratio_InsertValue_insts       numeric
kern_ratio_Load_insts              numeric
kern_ratio_Mul_insts               numeric
kern_ratio_Or_insts                numeric
kern_ratio_PHI_insts               numeric
kern_ratio_Ret_insts               numeric
kern_ratio_SDiv_insts              numeric
kern_ratio_SExt_insts              numeric
kern_ratio_SIToFP_insts            numeric
kern_ratio_SRem_insts              numeric
kern_ratio_Select_insts            numeric
kern_ratio_Shl_insts               numeric
kern_ratio_Store_insts             numeric
kern_ratio_Sub_insts               numeric
kern_ratio_Trunc_insts             numeric
kern_ratio_UDiv_insts              numeric
kern_ratio_Xor_insts               numeric
kern_ratio_ZExt_insts              numeric
kern_ratio_basic_blocks            numeric
kern_ratio_memory_instructions     numeric
kern_ratio_non_external_functions  numeric
dev_count                          numeric
dev_address_bits                   numeric
dev_double_fp_config               numeric
dev_endian_little                  numeric
dev_execution_capabilities         numeric
dev_extensions                     nominal
dev_global_mem_cache_size          numeric
dev_global_mem_cache_type          numeric
dev_global_mem_cacheline_size      numeric
dev_global_mem_size                numeric
dev_host_unified_memory            numeric
dev_image2d_max_height             numeric
dev_image2d_max_width              numeric
dev_image3d_max_depth              numeric
dev_image3d_max_height             numeric
dev_image3d_max_width              numeric
dev_image_support                  numeric
dev_local_mem_size                 numeric
dev_local_mem_type                 numeric
dev_max_clock_frequency            numeric
dev_max_compute_units              numeric
dev_max_constant_args              numeric
dev_max_constant_buffer_size       numeric
dev_max_mem_alloc_size             numeric
dev_max_parameter_size             numeric
dev_max_read_image_args            numeric
dev_max_samplers                   numeric
dev_max_work_group_size            numeric
dev_max_work_item_dimensions       numeric
dev_max_work_item_sizes_0          numeric
dev_max_work_item_sizes_1          numeric
dev_max_work_item_sizes_2          numeric
dev_max_write_image_args           numeric
dev_mem_base_addr_align            numeric
dev_min_data_type_align_size       numeric
dev_native_vector_width_char       numeric
dev_native_vector_width_double     numeric
dev_native_vector_width_float      numeric
dev_native_vector_width_half       numeric
dev_native_vector_width_int        numeric
dev_native_vector_width_long       numeric
dev_native_vector_width_short      numeric
dev_preferred_vector_width_char    numeric
dev_preferred_vector_width_double  numeric
dev_preferred_vector_width_float   numeric
dev_preferred_vector_width_half    numeric
dev_preferred_vector_width_int     numeric
dev_preferred_vector_width_long    numeric
dev_preferred_vector_width_short   numeric
dev_queue_properties               numeric
dev_single_fp_config               numeric
dev_type                           numeric
dev_vendor                         nominal
dev_vendor_id                      nominal
dev_version                        nominal
\end{Verbatim}
\end{multicols}


\section{Collective Tuning and the Client-Server Model}

\TODO{Three-tier client, proxy, server model. Include UML sequence
  diagrams and system diagram.}


\section{Autotuning using Classification}

The simplest autotuner is one which selects the workgroup size which
is most commonly optimal (i.e. the mode of all optimal workgroup sizes
$\left\{ \Omega(s) | s \in S \right\}$):

\begin{equation}
\text{ZeroR} = \text{mode}( \left\{ \Omega(s) | s \in S \right\} )
\end{equation}

However, this is not satisfactory for the purpose of selecting a
workgroup size to use, due to the constraint $W_{max}(s)$ enforced for
each scenario. As a result, we propose a so called ``OneR''
classifier, which first defines $W_{safe} \in W$ as the intersection
of legal workgroup sizes across all scenarios, then selects the
workgroup size $w$ which maximises the average performance
$\bar{p}(w)$ across this reduced parameter space.

\begin{align}
W_{safe} &= \cap \left\{ f(s) | s \in S \right\} \\
\text{OneR} &= \argmax_{w \in W_{safe}} \bar{p}(w)
\end{align}

This provides a baseline for comparing against a more sophisticated
autotuning approaches using machine learning.

\subsection{Satisfying Constraints}

Since classifiers are probabilistic systems, it is possible that a
classifier will predict a workgroup size that is invalid for the given
scenario, $w \not\in W_{legal}(s)$. In these cases, one of three
fallback strategies is used to select a safe workgroup size:

\begin{enumerate}
\item \emph{OneR} --- select the workgroup size which is known to be
  safe and provides the highest average case performance.
\item \emph{Random} --- select a random workgroup size uniformly from
  the set of legal values $w \in W_{legal}$.
\item \emph{Reshape} --- attempt to scale predicted the predicted
  workgroup size proportionally so that it fits within the space of
  legal workgroup sizes.
\end{enumerate}

The evaluation compares the average performance achieved using each
fallback strategy, along with the percentage of cases for which these
fallback strategies were required.

\subsection{Results}

\TODO{Evaluate the effectiveness of training with synthetic
  benchmarks.}


\section{Autotuning using Regression}

\TODO{If we could use regression to accurately predict the runtime or
  relative performance of different workgroup sizes, then we could
  overcome the expensive training cost of autotuning by
  classification.}

\subsection{Classification Using Regression}

\subsection{Results}


\section{Meta-tuning: a Hybrid Approach}

\begin{algorithm}
\caption{Request workgroup size}\label{bar}
\begin{algorithmic}[1]
\Require kernel features $k$, hardware features $h$, dataset features $d$.
\Ensure workgroup size $c$

\State $C \leftarrow \{ c_1, c_2,\ldots, c_n \}$
\Comment Set of all possible workgroup sizes

\If{no control flow in kernel}
    \State \textbf{return} $\underset{c}{\argmin} f(k,h,d,c) = r$
\Else
   \State converged $\leftarrow$ false
   \State $c_b \leftarrow$ baseline values
   \State $r_b \leftarrow$ measure runtime of runtime of program with $c_b$
   \While{not converged}
     \State return $\underset{c}{\argmax} g(k,h,d,c) = s$
     \State evaluate $c$, measuring runtime $r$\;
     \If{measured speedup $\frac{r_b}{r} \approx$ predicted speedup $s$}
       \State converged = true
     \Else
       \State $C = C - \{c\}$
     \EndIf
   \EndWhile
   \State \textbf{return} $c$
\EndIf
\end{algorithmic}
\end{algorithm}

\section{Summary}
