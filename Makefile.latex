#
# Makefile.latex - Common Makefile for building LaTeX documents.
#
# Ensure that any Makefile which includes this defines the $(Document)
# and $(DocumentSources) variables. The $(Document) variable is the
# name of the target LaTeX source file without the file extension, and
# $(DocumentSources) is a space delimited list of LaTeX source files.
# For example:
#
#     Document = report
#     DocumentSources = chapter1.tex appendix.tex abstract.tex
#
include $(top_srcdir)/Makefile.common

#------------------------------------------------------------------------
# Build configuration.
#------------------------------------------------------------------------
DocumentPDF = $(Document).pdf
DocumentTex = $(Document).tex
DocumentAux = $(Document).aux
DocumentBuildLog = make.log
DocumentBibfile = refs.bib

# The full list of input files read by pdflatex. This is grabbed from
# the .fls that is generated by pdflatex. As a result, if we haven't
# run pdflatex before, there will be no .fls file, so we just return
# the $(DocumentTex) file.
DocumentDependencies    = \
	$(shell test -f $(Document).fls				\
		&& $(EGREP) '^INPUT ' $(Document).fls		\
		| $(AWK) ' !x[$$0]++' | $(SED) 's/^INPUT //'	\
		|| echo $(DocumentTex))
# The full list of input .tex files read by pdflatex.
DocumentTexDependencies = $(filter %.tex,$(DocumentDependencies))
# The list of .tex files which are local to this project, i.e. don't
# contain absolute paths.
DocumentSources         = $(filter-out /%,$(DocumentTexDependencies))
# Add the local .tex files to the $(Sources) variable.
Sources                += $(DocumentSources)

PdflatexArgs = 				\
	-recorder			\
	-output-format pdf 		\
	-progname pdflatex 		\
	-file-line-error 		\
	-interaction=nonstopmode	\
	$(NULL)

# Import lib/*.sty libraries.
export TEXINPUTS := .:./lib:$(TEXINPUTS)

# The cleanbib script.
CLEANBIB = $(top_srcdir)/scripts/cleanbib

# The system-wide LaTeX library name.
BIBLIBRARY = library

MOSTLYCLEANFILES +=                     \
	$(DocumentPDF) 			\
	$(Document).fls			\
	$(DocumentBuildLog)		\
	*-blx.bib 			\
	*.acn 				\
	*.acr 				\
	*.alg 				\
	*.aux 				\
	*.bbl 				\
	*.bcf 				\
	*.blg 				\
	*.dvi 				\
	*.fdb_latexmk 			\
	*.glg 				\
	*.glo 				\
	*.gls 				\
	*.idx 				\
	*.ilg 				\
	*.ind 				\
	*.ist 				\
	*.lof 				\
	*.log 				\
	*.lol 				\
	*.lot 				\
	*.maf 				\
	*.mtc 				\
	*.mtc0 				\
	*.nav 				\
	*.nlo 				\
	*.out 				\
	*.pdfsync 			\
	*.ps 				\
	*.run.xml 			\
	*.snm 				\
	*.synctex.gz			\
	*.tdo 				\
	*.toc 				\
	*.vrb 				\
	*.xdy 				\
	$(NULL)

#------------------------------------------------------------------------
# Local build rules.
#------------------------------------------------------------------------

# If we have xdg-open then we can open the PDF.
if HAVE_XDG_OPEN
PhonyTargets += open
open:
	$(AM_V_at)if [ -f $(DocumentPDF) ]; then			\
		$(XDG_OPEN) $(DocumentPDF) >/dev/null 2>&1 &		\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi
endif

# If we have texcount then we can perform word counts.
if HAVE_TEXCOUNT
PhonyTargets += wc

wc: $(Document).wc
	$(AM_V_at)$(SED) '1,/total/Id' < $<				\
		| $(EGREP) --color=never '^(Words|Number)'

# Generate a word count file.
$(Document).wc: $(DocumentSources)
	$(AM_V_at)if [ -f $(DocumentPDF) ]; then			\
		$(TEXCOUNT) $(DocumentSources) > $(Document).wc; 	\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi

MOSTLYCLEANFILES += $(Document).wc
endif

# If we have checkcites then we can perform citation checks.
if HAVE_CHECKCITES
PhonyTargets += cite

cite: $(Document).cite
	$(AM_V_at)cat $<

# Generate a citation check file.
$(Document).cite: $(DocumentSources)
	$(AM_V_at)if [ -f $(DocumentPDF) ]; then			\
		$(CHECKCITES) --undefined $(DocumentAux) > $@;		\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi

MOSTLYCLEANFILES += $(Document).cite
endif

# If we have textlint then we can perform writing style checks.
if HAVE_TEXTLINT
PhonyTargets += style lint

# The process for caching the result of textlint is a little bit more
# complicated than the "wc" or "cite" rules. Since textlint is a slow
# process to run, we invoke it while using the "tee" command in order
# to simultaneously print the results to stdout while caching them for
# future retrieval. As a result, a use the file .$(Document).lint to
# indicate whether we have just generated the files, so that cache-hit
# rule doesn't print the cached results that we've just generated.
style lint: $(Document).lint
	$(AM_V_at)if [ ! -f .$(Document).lint ]; then			\
		cat $(Document).lint;					\
	fi
	$(AM_V_at)$(RM) .$(Document).lint

# Run textlint and cache results.
$(Document).lint: $(DocumentSources)
	$(AM_V_at)if [ -f $(DocumentPDF) ]; then			\
		$(RM) $(Document).lint;					\
		for f in $(DocumentSources); do				\
			echo -e "\n*** $$f ***" | tee --append $@;	\
			$(TEXTLINT) $$f | tee --append $@;		\
		done;							\
		touch .$(Document).lint;				\
	else								\
		$(MAKE) $(DocumentPDF);					\
		$(MAKE) $@;						\
	fi

MOSTLYCLEANFILES += $(Document).lint .$(Document).lint
endif

# Print make targets.
help-local:
	@echo "Build targets:"
	@echo
	@echo "  make all       Compile $(DocumentPDF)"
	@echo "  make clean     Remove all build files"
if HAVE_XDG_OPEN
	@echo "  make open      Open $(DocumentPDF) in default PDF viewer"
endif
if HAVE_TEXCOUNT
	@echo "  make wc        Show a word count"
endif
if HAVE_CHECKCITES
	@echo "  make cite      Check citations"
endif
if HAVE_TEXTLINT
	@echo "  make style     Check writing style"
endif

#------------------------------------------------------------------------
# Compiling PDF LaTeX documents.
#------------------------------------------------------------------------

doc_DATA = $(DocumentPDF)
$(DocumentPDF): $(DocumentDependencies)

# Compile commands. We pipe the output to /dev/null to silence it, and
# if there is an error, we re-run the compilation without the pipe so
# as to print the failure messages.
define pdflatex
	(echo -e "\nCOMMAND: $(PDFLATEX) $(PdflatexArgs) $1\n" >>$(DocumentBuildLog); \
	 $(PDFLATEX) $(PdflatexArgs) $1 2>&1 >>$(DocumentBuildLog) || $(PDFLATEX) $(PdflatexArgs) $1)
endef

define bibtex
	(echo -e "\nCOMMAND: $(BIBTEX) $1\n" >>$(DocumentBuildLog);	\
	 $(BIBTEX) $1 2>&1 >>$(DocumentBuildLog) || $(BIBTEX) $1)
endef

define bibtool
	(echo -e "\nCOMMAND: $(BIBTOOL) -x $1 -o $2\n" >>$(DocumentBuildLog); \
	 $(BIBTOOL) -v -x $1 -o $2 &>>$(DocumentBuildLog) || $(BIBTOOL) -v -x $1 -o $2)
endef

define cleanbib
	(echo -e "\nCOMMAND: $(CLEANBIB) $1\n" >>$(DocumentBuildLog); \
	 $(CLEANBIB) $1 &>>$(DocumentBuildLog) || $(CLEANBIB) $1)
endef

# The LaTeX build target. This gnarly bit of shell hackery uses nested
# conditionals and sub-shells to invoke pdflatex, bibtex, bibtool, and
# cleanbib the correct number of times depending on the document
# contents. The sequence of program invocations is as follows:
#
# 1. pdflatex
# -  If the document contains citations:
# 2.     bibtex
# -      If the document uses the global biblibrary:
# 3.          bibtool
# 4.          cleanbib
# 5.     pdflatex
# 6.  pdflatex
%.pdf: %.tex
	$(AM_V_at)echo -e "Build log for `date`\n" >$(DocumentBuildLog)
	@if ! $(AM_V_P); then echo '  LATEX    $@'; fi
	$(AM_V_at)$(call pdflatex, $<)
	$(AM_V_at)($(GREP) '\\citation' >/dev/null 2>&1 < $*.aux && {	\
			if ! $(AM_V_P); then echo "  BIBTEX   $@"; fi;	\
			$(call bibtex, $*);				\
			$(EGREP) '\\bibdata.*$(BIBLIBRARY)' $*.aux >/dev/null 2>&1 && { \
				if ! $(AM_V_P); then echo '  BIBTOOL  $(DocumentBibfile)'; fi; \
				$(call bibtool,$*.aux,$(DocumentBibfile)); \
				$(call cleanbib,$(DocumentBibfile));	\
			} || true;					\
			if ! $(AM_V_P); then echo '  LATEX    $@'; fi;	\
			$(call pdflatex, $<);				\
		} || true)
	@if ! $(AM_V_P); then echo '  LATEX    $@'; fi
	$(AM_V_at)$(call pdflatex, $<)
