#!/usr/bin/env python2.7
#
# e13 - Tuning number of iterations between swaps for iterative
# Stencil applications on multi-GPUs.
#
from __future__ import print_function
from copy import copy
from itertools import product
from operator import mul
from re import sub
from sys import stdout

from benchlib import *
from skelcl import *
from util import *

import config

class SimpleBigKnob(Knob):
    cxxSrc = path(SKELCL, 'examples/SimpleBig/main.cpp')
    clSrc = path(SKELCL, 'examples/SimpleBig/kernels.cl')

class BorderSize(SimpleBigKnob):
    def __init__(self, val):
        SimpleBigKnob.__init__(self, "BorderSize", val)

    def set(self, **kwargs):
        os.system("sed -r -i 's/(define NORTH) [0-9]+/\\1 {val}/' {path}"
                  .format(val=self.val[0], path=self.cxxSrc))
        os.system("sed -r -i 's/(define WEST) [0-9]+/\\1 {val}/' {path}"
                  .format(val=self.val[1], path=self.cxxSrc))
        os.system("sed -r -i 's/(define SOUTH) [0-9]+/\\1 {val}/' {path}"
                  .format(val=self.val[2], path=self.cxxSrc))
        os.system("sed -r -i 's/(define EAST) [0-9]+/\\1 {val}/' {path}"
                  .format(val=self.val[3], path=self.cxxSrc))

jobdesc =  {
    "hosts": [ "florence", "cec", "dhcp-90-060", "whz5", "tim", "monza" ],
    "benchmarks": {
        "SimpleBig": {
            "args": {
                "Size": ["-w {w} -h {h}".format(w=x[0], h=x[1]) for x in [
                    [1024, 1024],
                    [2048, 2048]
                ]],
                "Complexity": ["", "--complex"]
            }
        }
    },
    "args": {},
    "knobs": {
        BorderSize: [
            [ 1,  1,  1,  1],
            [ 5,  5,  5,  5],
            [10, 10, 10, 10],
            [20, 20, 20, 20],
            [30, 30, 30, 30],
            [ 1, 10, 30, 30],
            [20, 10, 20, 10]
        ],
        StencilLocalSizeC: [4, 32, 64],
        StencilLocalSizeR: [4, 32, 64]
    }
}

# Check that values are legal.
def knobvaluesarelegal(host, devargs, knobs):
    # Get the available devices.
    cpus, gpus = host.getDevices()

    # Calculate the workgroup size.
    wg = [lookup1(knobs, StencilLocalSizeC).val,
          lookup1(knobs, StencilLocalSizeR).val]
    workgroupsize = wg[0] * wg[1]

    # Determine the target device.
    devices = gpus if search("GPU", devargs[0].val) else cpus

    # Find the smallest max work group size from those devices.
    hardwareMaxWorkGroupSize = min([x["max_work_group_size"] for x in devices])

    # Detmine whethe the proposed work group size is smaller than the
    # hardware enforced maximum.
    return hardwareMaxWorkGroupSize >= workgroupsize

def instantiate(host, benchmark, args, knobs):
    sampler = SkeletonEventTimingsSampler()
    harnesses = []

    for devargs in host.devargs():
        if knobvaluesarelegal(host, devargs, knobs):
            c = SkelCLTestCase(benchmark, host=host,
                               invars=knobs + args + devargs)
            harnesses.append(TestHarness(c, sampler))

    return harnesses

HARNESSES = enumerateHarnesses(jobdesc, instantiate)

q = jobqueue(HARNESSES)

runJobQueue(q)

# Headless servers stop here.
if not masterhost(): exit(0)

####### DATA PROCESSING

from re import sub

from stats import *

import plot as plt

def getworkgroupsize(invars):
    return (lookup1(invars, StencilLocalSizeC),
            lookup1(invars, StencilLocalSizeR))

def getinputsize(invars):
    size_arg = lookup1(invars, "Size").val
    width  = search("-w (\d+)", size_arg).group(1)
    height = search("-h (\d+)", size_arg).group(1)
    return int(width), int(height)

def getcomplexity(invars):
    return 1 if lookup1(invars, "Complexity").val else 0

def setworkgroupsize(invars, *newWgSize):
    newinvars = copy(invars)

    # Lookup existing values.
    workgroupsize = getworkgroupsize(newinvars)

    # Remove existing value(s).
    [newinvars.remove(x) for x in workgroupsize]
    [newinvars.append(x) for x in newWgSize]

    return newinvars

def gettime(result):
    inittimes, buildtimes, preptimes, ultimes, skeltimes, swaptimes, dltimes = gettimes(result.outvars)
    return describe(skeltimes)

def humanReadableDeviceString(invars):
    s = ""

    deviceType = lookup1(invars, DeviceTypeArg).val

    if search("GPU", deviceType):
        # Get the --device-count argument.
        deviceCountArg = lookup1(invars, DeviceCountArg).val
        # Get the numerical count.
        deviceCount = search('([0-9]+)', deviceCountArg).group(1)
        return "{count}xGPU".format(count=deviceCount)
    else:
        return "CPU"

# Plot speedups of kernel for a fixed Device and Kernel type.
def plotSpeedupsForDeviceAndWorkGroup(harnesses):
    speedups = [lookup1(x.result().couts, Speedup).val for x in harnesses]
    borders = [lookup1(x.testcase.invars, BorderSize).val for x in harnesses]
    complexities = [lookup1(x.testcase.invars, "Complexity").val for x in harnesses]

    # Constants across all harnesses:

    width, height = getinputsize(harnesses[0].testcase.invars)
    hostname = lookup1(harnesses[0].testcase.invars, Hostname).val
    devicename = humanReadableDeviceString(harnesses[0].testcase.invars)

    iterations = sum([x[2] for x in speedups]) / len(speedups)

    # Work group size.
    workgroup = [
        lookup1(harnesses[0].testcase.invars, StencilLocalSizeC).val,
        lookup1(harnesses[0].testcase.invars, StencilLocalSizeR).val
    ]

    # Unique plot ID.
    plotId = ("-".join([str(x) for x in [
        hostname,
        devicename,
        workgroup[0],
        workgroup[1],
        width,
        height
    ]]))
    plotPath = path(config.RESULTS, config.ID, "kernel", plotId + ".png")

    # Plot title.
    title = ("Work group size: [{c} x {r}]. {hostname} "
             "{device} {width}x{height}"
             .format(c=workgroup[0], r=workgroup[1],
                     hostname=hostname, device=devicename,
                     width=width, height=height))

    # Plot caption.
    caption = "Average {n:.1f} iterations.".format(n=iterations)

    # Datapoints:

    Y   = [x[0] for x in speedups]
    Err = [x[1] for x in speedups]

    # Create xtick labels.
    Labels = []
    for i in range(len(harnesses)):
        border = borders[i]
        is_complex = complexities[i]
        label = "\\textbf{" if is_complex else ""
        label += "[{0}]".format(" ".join([str(x) for x in border]))
        if is_complex: label += "}"
        Labels.append(label)

    # Keyword arguments to speedup.
    kwargs = {
        "title":     title,
        "xlabel":    "Border size and kernel complexity",
        "labels":    Labels,
        "err":       Err,
        "caption":   caption,
        "path":      plotPath
    }

    plt.speedups(Y, **kwargs)

# Plot speedups of work group size and kernel type for a fixed device.
def plotSpeedupsForDevice(groups):
    # Workgroup sizes
    wgVars = [getworkgroupsize(x[0].testcase.invars) for x in groups]
    wgSizes = [(x[0].val, x[1].val) for x in wgVars]
    width, height = getinputsize(groups[0][0].testcase.invars)

    # Constants across all harnesses:

    hostname = lookup1(groups[0][0].testcase.invars, Hostname).val
    devicename = humanReadableDeviceString(groups[0][0].testcase.invars)

    # Constants across all groups:

    borders = [lookup1(x.testcase.invars, BorderSize).val for x in groups[0]]
    complexities = [lookup1(x.testcase.invars, "Complexity").val for x in groups[0]]

    # Flatten grid data into a list:
    speedups = []
    for harnesses in groups:
        speedups += [lookup1(x.result().couts, Speedup).val for x in harnesses]

    iterations = sum([x[2] for x in speedups]) / len(speedups)

    # Unique plot ID.
    plotId = ("-".join([str(x) for x in [
        hostname,
        devicename,
        width,
        height
    ]]))
    plotPath = path(config.RESULTS, config.ID, "wg-kernel", plotId + ".png")

    # Plot title.
    title = ("{hostname} {device} {width}x{height}"
             .format(hostname=hostname, device=devicename,
                     width=width, height=height))

    # Plot caption.
    caption = "Average {n:.1f} iterations.".format(n=iterations)

    # Datapoints:

    Y   = [x[0] for x in speedups]

    # Create xtick labels.
    Xlabels = []
    for i in range(len(borders)):
        border = borders[i]
        is_complex = complexities[i]
        label = "\\textbf{" if is_complex else ""
        label += "[{0}]".format(" ".join([str(x) for x in border]))
        if is_complex: label += "}"
        Xlabels.append(label)

    Ylabels = ["[{c} x {r}]".format(c=x[0], r=x[1]) for x in wgSizes]

    # Keyword arguments to speedup.
    kwargs = {
        "surface":   False, # Surface or bar plot.
        "title":     title,
        "xlabel":    "",#"Border size and kernel complexity",
        "ylabel":    "",#"Work group size",
        "zlabel":    "Speedup",
        "xlabels":   Xlabels,
        "ylabels":   Ylabels,
        "caption":   caption,
        "path":      plotPath,
    }

    plt.speedups3d(Y, len(groups[0]), **kwargs)

# Plot speedups of work group sizes for each a fixed device and kernel.
def plotSpeedupsForDeviceAndKernel(harnesses):
    # Workgroup sizes
    wgVars = [getworkgroupsize(x.testcase.invars) for x in harnesses]
    wgSizes = [(x[0].val, x[1].val) for x in wgVars]

    # Constants across all harnesses:

    width, height = getinputsize(harnesses[0].testcase.invars)
    hostname = lookup1(harnesses[0].testcase.invars, Hostname).val
    devicename = humanReadableDeviceString(harnesses[0].testcase.invars)
    border = lookup1(harnesses[0].testcase.invars, BorderSize).val
    complexity = lookup1(harnesses[0].testcase.invars, "Complexity").val

    kernelString = "[{0}]".format(",".join([str(x) for x in border]))
    if complexity: kernelString += "c"

    # Get X,Y cordinate ranges values
    Xvals, Yvals = [], []
    for x in wgSizes:
        if x[0] not in Xvals: Xvals.append(x[0])
        if x[1] not in Yvals: Yvals.append(x[1])
    Xvals = list(reversed(sorted(Xvals)))
    Yvals = list(sorted(Yvals))

    # Create empty data list:
    speedups = [(0, 0, 0) for i in range(len(Xvals) * len(Yvals))]
    # Populate data:
    for i in range(len(harnesses)):
        # Get harness and work group size
        harness = harnesses[i]
        wg = wgSizes[i]

        # Calculate x,y position and 1D array index
        x, y = Xvals.index(wg[0]), Yvals.index(wg[1])
        index = y * len(Xvals) + x

        # Add speedup
        speedups[index] = lookup1(harness.result().couts, Speedup).val

    iterations = sum([x[2] for x in speedups]) / len(speedups)

    # Unique plot ID.
    plotId = "-".join([str(x) for x in [
        kernelString,
        width,
        height
    ]])
    plotPath = path(config.RESULTS, config.ID, "wg",
                    hostname + "-" + devicename, plotId + ".png")

    # Plot title.
    title = ("{hostname} {device} {kernel} {width}x{height}"
             .format(hostname=hostname, device=devicename, kernel=kernelString,
                     width=width, height=height))

    # Plot caption.
    caption = "Average {n:.1f} iterations.".format(n=iterations)

    # Datapoints:

    Y   = [x[0] for x in speedups]

    # Create xtick labels.
    Xlabels = Xvals
    Ylabels = Yvals

    # Keyword arguments to speedup.
    kwargs = {
        "surface":   False, # Surface or bar plot.
        "title":     title,
        "xlabel":    "Work group size (C)",
        "ylabel":    "Work group size (R)",
        "zlabel":    "Speedup",
        "xlabels":   Xlabels,
        "ylabels":   Ylabels,
        "caption":   caption,
        "path":      plotPath,
    }

    plt.speedups3d(Y, len(Xvals), **kwargs)

# Return the workgroup size and speedup value of the best speedup.
def getBestSpeedupFromHarnesses(harnesses):
    bestharness, bestspeedup = None, 0

    # Iterate over all harnesses to find the best speedup.
    for harness in harnesses:
        speedup = lookup1(harness.result().couts, Speedup).val[0]

        if speedup > bestspeedup:
            bestharness = harness
            bestspeedup = speedup

    # Test to see if we have a result.
    if bestharness:
        bestWgVars = getworkgroupsize(bestharness.testcase.invars)
        bestWg = (bestWgVars[0].val, bestWgVars[1].val)
    else:
        bestWg = None

    return bestWg, bestspeedup


def kernelString(invars, tex=False):
    border = lookup1(invars, BorderSize).val
    complexity = lookup1(invars, "Complexity").val

    string = "[{0}]".format(",".join([str(x) for x in border]))
    if complexity:
        if tex:
            string = "\\textbf{" + string + "}"
        else:
            string += "c"

    return string

def tprint(*args, **kwargs):
    # Characters to escape.
    escape_chars = ["[", "]"]

    escaped = [str(x) for x in args]
    for i in range(len(escaped)):
        for escape_char in escape_chars:
            if escape_char in escaped[i]:
                escaped[i] = escaped[i].replace(escape_char, "{" + escape_char + "}")

    if "end" not in kwargs: kwargs["end"] = "\\\\\n"

    print(" & ".join(escaped), **kwargs)

def createArff(harnesses, file=stdout):
    # Dataset.
    data = []

    # Group harnesses by explanatory variable values.
    groups = groupByInvars(harnesses,
                           Hostname, DeviceTypeArg, DeviceCountArg,
                           BorderSize, "Complexity", "Size").values()

    # Iterate over each group.
    for group in groups:
        # Get the best work group size and speedup.
        wg, speedup = getBestSpeedupFromHarnesses(group)

        invars = group[0].testcase.invars
        border = lookup1(invars, BorderSize).val
        deviceArgs = lookup1(invars, DeviceTypeArg).val

        # Get the attribute values.
        hostname = lookup1(invars, Hostname).val
        device = "f" # TODO: get device id
        if search("GPU", deviceArgs):
            deviceType = "GPU"
            deviceCountArg = lookup1(invars, DeviceCountArg).val
            deviceCount = int(search("(\d+)", deviceCountArg).group(1))
        else:
            deviceType = "CPU"
            deviceCount = 1
        borderNorth = border[0]
        borderEast = border[1]
        borderSouth = border[2]
        borderWest = border[3]
        dataWidth, dataHeight = getinputsize(invars)
        complexity = getcomplexity(invars)
        if wg == None:
            # We're deliberately excluding cases where no results were
            # found.
            continue
        else:
            localSize = "{w}x{h}".format(w=wg[0], h=wg[1])

        # Set the attributes.
        attributes = [
            ("Hostname", "NOMINAL", hostname),
            ("Dev", "NOMINAL", device),
            ("DevType", "NOMINAL", deviceType),
            ("DevCount", "NUMERIC", deviceCount),
            ("BorderNorth", "NUMERIC", borderNorth),
            ("BorderEast", "NUMERIC", borderEast),
            ("BorderSouth", "NUMERIC", borderSouth),
            ("BorderWest", "NUMERIC", borderWest),
            ("DataWidth", "NUMERIC", dataWidth),
            ("DataHeight", "NUMERIC", dataHeight),
            ("Complexity", "NOMINAL", complexity),
            ("LocalSize", "NOMINAL", localSize)
        ]

        # Add a row to dataset.
        data.append([x[2] for x in attributes])

    # Set the schema.
    schema = [(x[0], x[1]) for x in attributes]

    # Determine the path to the output file.
    arffPath = path(config.RESULTS, config.ID, "data.arff")

    # Write the output file.
    mkarff(schema, data, relation="e14", file=mkopen(arffPath, "w"))

def tableBestSpeedupsForKernel(harnesses, path):
    kGrouped = groupByInvars(harnesses, BorderSize, "Complexity", "Size").values()

    wgs = []
    speedups = []

    # Create gride of information.
    for kGroup in kGrouped:
        # Group by device.
        deviceGrouped = groupByInvars(kGroup, Hostname, DeviceTypeArg,
                                      DeviceCountArg).values()

        # Get best work group size and speedup for each device.
        w, s = zip(*[getBestSpeedupFromHarnesses(x)
                     for x in deviceGrouped])

        # Add to data grids.
        wgs.append(w)
        speedups.append(s)

    numDistinctDevVals = []
    numDistinctKernVals = []

    numRows = len(wgs)
    numCols = len(wgs[0])

    # Count the number of distint best values (row-wise)
    for row in range(numRows):
        allVals = filter(lambda x: x != None, wgs[row])
        uniqVals = set(allVals)
        if len(allVals):
            ratio = int((len(uniqVals) / float(len(allVals))) * 100)
        else:
            ratio = 0
        numDistinctKernVals.append("{n} ({r}\\%)".format(n=len(uniqVals),
                                                         r=ratio))

    # Count the number of distinct best values (col-wise)
    for col in range(numCols):
        allVals = filter(lambda x: x != None,
                         [wgs[i][col] for i in range(numRows)])
        uniqVals = set(allVals)
        if len(allVals):
            ratio = int((len(uniqVals) / float(len(allVals))) * 100)
        else:
            ratio = 0
        numDistinctDevVals.append("{n} ({r}\\%)".format(n=len(uniqVals),
                                                        r=ratio))

    # Open output file
    file = mkopen(path, "w")

    print("\\begin{{tabular}}{{|{sep}|}}"
          .format(sep=(" | ".join(["p{1.8cm}"] +
                                  ["p{1cm}" for x in kGrouped[4:]] +
                                  ["p{1.1cm}"]))), file=file)

    # Print device strings as header.
    deviceGrouped = groupByInvars(kGrouped[0], Hostname, DeviceTypeArg,
                                  DeviceCountArg).values()
    deviceStrings = [("\\textbf{{{host} {dev}}}"
                      .format(host=lookup1(x[0].testcase.invars, Hostname).val,
                              dev=humanReadableDeviceString(x[0].testcase.invars)))
                     for x in deviceGrouped]
    tprint("\\hline", end="\n", file=file)
    tprint(*["\\textbf{Kernel}"] + deviceStrings + ["\\textit{Unique}"], file=file)
    tprint("\\hline", end="\n", file=file)

    for i in range(len(kGrouped)):
        # Kernel string.
        kernel = kernelString(kGrouped[i][0].testcase.invars, tex=True)

        tprint(*[kernel] + list(wgs[i]) + [numDistinctKernVals[i]], file=file)

    # Print uniq vlas.
    tprint("\\hline", end="\n", file=file)
    tprint(*["\\textit{Unique}"] + numDistinctDevVals + [""], file=file)

    # Print footer.
    tprint("\\hline", end="\n", file=file)
    print("\\end{tabular}", file=file)

    # Print completion message.
    Colours.print(Colours.BLUE, "Wrote {path} ...".format(path=file.name))

# Preprocess data: Add derived speedups over default work group sizes.
for harness in HARNESSES:
    result = harness.result()
    invars = result.invars

    # Get the baseline result.
    baselineinvars = setworkgroupsize(invars,
                                      StencilLocalSizeC(StencilLocalSizeC.DEFAULT),
                                      StencilLocalSizeR(StencilLocalSizeR.DEFAULT))
    baseline = resultscache.load(baselineinvars)

    if (baseline.bad or result.bad or
        not len(baseline.outvars) or not len(result.outvars)):
        # If we are missing data, speedup = 0.
        speedup = 0
        err = 0
    else:
        # Else, speedup = Tb / Tc
        time = gettime(result)
        baselinetime = gettime(baseline)
        speedup = baselinetime[0] / time[0]
        err = abs((baselinetime[0] / sum(time)) - speedup)
    # Average number of iterations.
    iterations = sum([len(result.outvars), len(baseline.outvars)]) / 2
    # Add Speedup cout variable.
    result.couts.add(Speedup((speedup, err, iterations)))

# Create a .arff dataset file.
createArff(HARNESSES)

harnesses_1024 = filterHarnessesByInvarVal(HARNESSES, "Size", "-w 1024 -h 1024")
harnesses_2048 = filterHarnessesByInvarVal(HARNESSES, "Size", "-w 2048 -h 2048")

tableBestSpeedupsForKernel(harnesses_1024, path(config.RESULTS, config.ID,
                                                "bestSpeedupsForKernel-1024.tex"))
tableBestSpeedupsForKernel(harnesses_2048, path(config.RESULTS, config.ID,
                                                "bestSpeedupsForKernel-2048.tex"))

# Group harnesses by Host/Device properties.
deviceGrouped = groupByInvars(HARNESSES, Hostname, DeviceTypeArg,
                              DeviceCountArg, "Size").values()

# Iterate over groups.
for deviceGroup in deviceGrouped:
    # Group harnesses by work group size.
    wgGrouped = groupByInvars(deviceGroup,
                              StencilLocalSizeC,
                              StencilLocalSizeR).values()
    # Plot speedups of work group sizes and kernels for each device.
    plotSpeedupsForDevice(wgGrouped)

    # Plot speedups of kernels for each device and work group size.
    [plotSpeedupsForDeviceAndWorkGroup(x) for x in wgGrouped]

    # Group harnesses by kernel type.
    kGrouped = groupByInvars(deviceGroup,
                             BorderSize,
                             "Complexity").values()

    # Plot speedups of work group sizes for each device and kernel.
    [plotSpeedupsForDeviceAndKernel(x) for x in kGrouped]

# Graph event times.
[plt.openCLEventTimes(x.testcase.invars) for x in HARNESSES]

exit(0)
