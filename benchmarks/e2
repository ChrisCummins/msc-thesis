#!/usr/bin/env python2.7

from __future__ import print_function
from operator import itemgetter
from re import sub
from sys import exit
from operator import mul
import os

gui = True

if gui:
    import numpy as np
    import matplotlib.pyplot as plt

from benchlib import *

paramrange = [8, 16, 32, 64, 128]

# The default parameter values.
BASE = [32, 8, 16]
BASESTRING = '-'.join([str(x) for x in BASE])

def pre_exec_hook(settings):
    cd(CWD)
    os.system("sed -r -i 's/(define KNOB_C) [0-9]+/\\1 {0}/' ../skelcl/include/SkelCL/detail/AllPairsDef.h"
              .format(settings['c']))
    os.system("sed -r -i 's/(define KNOB_R) [0-9]+/\\1 {0}/' ../skelcl/include/SkelCL/detail/AllPairsDef.h"
              .format(settings['r']))
    os.system("sed -r -i 's/(define KNOB_S) [0-9]+/\\1 {0}/' ../skelcl/include/SkelCL/detail/AllPairsDef.h"
              .format(settings['s']))

    os.system("sed -r -i 's/(define GENERIC_KNOB_C) [0-9]+/\\1 {0}/' ../skelcl/include/SkelCL/detail/AllPairsDef.h"
              .format(settings['c']))
    os.system("sed -r -i 's/(define GENERIC_KNOB_R) [0-9]+/\\1 {0}/' ../skelcl/include/SkelCL/detail/AllPairsDef.h"
              .format(settings['r']))
    os.system("sed -r -i 's/(define GENERIC_KNOB_S) [0-9]+/\\1 {0}/' ../skelcl/include/SkelCL/detail/AllPairsDef.h"
              .format(settings['s']))

    os.system('make -C ../skelcl/build/examples/MatrixMultiply')

experiment = {
    'have_data': True,
    'name': 'e2',
    'iterations': 30,
    'settings': {
        'c': paramrange,
        'r': paramrange,
        's': paramrange
    },
    'pre-exec-hook': pre_exec_hook,
    'progs': {
        'MatrixMultiply': [
            ['-i 10'],
            ['--row_count_A 1024 --col_count_A 1024 --col_count_B 1024',
             '--row_count_A 2048 --col_count_A 2048 --col_count_B 2048',
             '--row_count_A 4096 --col_count_A 2048 --col_count_B 4096']
        ]
    }
}

if ID() != "cec":
    for prog in experiment['progs']:
        experiment['progs'][prog].append(['--device-type GPU'])

# GATHER DATA
if not experiment['have_data']:
    runexperiment(experiment)

class Result:
    def __init__(self, program, arguments, id, settings, dvars):
        self.program = program
        self.arguments = arguments
        self.id = id
        self.settings = settings
        self.dvars = dvars

    def __repr__(self):
        return ("{program} {arguments}, {id}, {settings}, {dvars}."
                .format(program=self.program,
                        arguments=self.arguments,
                        id=id,
                        settings="{{{0}}}".format(', '.join(
                            ['{key}: {val}'.format(key=x, val=self.settings[x]) for x in self.settings])),
                        dvars="{{{0}}}".format(', '.join(
                            ['{key}: {val}'.format(key=x, val=self.dvars[x]) for x in self.dvars]))))

# Gather all results.
globalresults = []
allids = set()
allargs = {}
for prog in experiment['progs']:
    allargs[prog] = set()
    for settings in settingspermutations(experiment['settings']):
        name = "-".join([experiment['name']] + [str(settings[x]) for x in settings])
        R = load(name)
        if not R: # Skip ahead if we haven't collected results yet.
            print("Skipping", name)
            continue

        for args in R[prog]:
            allargs[prog].add(args)
            for id in R[prog][args]:
                allids.add(id)
                baseline = mean(results(prog, args, id=id,
                                        version="-".join([experiment['name'],
                                                          BASESTRING])))

                if not baseline:
                    print("ERROR: no baseline found for {0}!"
                          .format('-'.join([prog, args, id, '-'.join([str(settings[x]) for x in settings])])))

                # Dependent variables.
                times = R[prog][args][id]

                # Derived speedups.
                speedups = [baseline / float(x) for x in times]
                # Derive mean and error from CI for speedups.
                speedup = baseline / mean(times)
                err = confinterval(speedups)[1] - speedup

                dvars = {
                    'row-count-A': int(search('--row_count_A ([0-9]+)', args).group(1)),
                    'col-count-A': int(search('--col_count_A ([0-9]+)', args).group(1)),
                    'col-count-B': int(search('--col_count_B ([0-9]+)', args).group(1)),
                    'times': times,
                    'speedup': speedup,
                    'err': err
                }

                r = Result(prog, args, id, settings, dvars)
                globalresults.append(r)

if not gui:
    print("Finished collecting results.")
    exit(0)

# Generate graphs.
for prog in experiment['progs']:
    for args in allargs[prog]:
        for id in allids:
            # Filter reulsts for graph.
            rresults = [x for x in globalresults if
                        x.program == prog and
                        x.arguments == args and
                        x.id == id]

            # We may not have collected data for all machines.
            if not len(rresults):
                continue

            size = [
                rresults[0].dvars['row-count-A'],
                rresults[0].dvars['col-count-A'],
                rresults[0].dvars['col-count-B']
            ]

            xvals               = range(len(rresults))
            yvals               = [x.dvars['speedup']     for x in rresults]
            yerrs               = [x.dvars['err']         for x in rresults]
            labels              = ['-'.join([str(x.settings[j]) for j in x.settings]) for x in rresults]
            meanruntime    = mean([mean(x.dvars['times']) for x in rresults])
            meaniterations = mean([len(x.dvars['times'])  for x in rresults])

            title = ("{program}: [{i}, {j}] x [{j} {k}] elements, {id}"
                     .format(program=rresults[0].program,
                             i=size[0],
                             j=size[1],
                             k=size[2],
                             id=rresults[0].id))

            # File name and path.
            name = ("{program}-{size}-{id}.png"
                     .format(program=rresults[0].program,
                             size='-'.join([str(x) for x in size]),
                             id=rresults[0].id))
            imgpath = path(RESULTSDIR, experiment['name'], name)

            # Create plot.
            fig, ax = plt.subplots()
            fig.set_size_inches(10, 6) # Set plot size
            bars = ax.bar(xvals, yvals, yerr=yerrs, ecolor='k')

            # FIXME: why the fuck is this offset necessary?
            MAGICOFFSET = 4
            defaultindex = rresults.index([x for x in rresults if
                                           '-'.join([str(x.settings[i])
                                                     for i in x.settings])
                                           == BASESTRING][0]) + MAGICOFFSET
            greenindexes = [x + MAGICOFFSET
                            for x,v in enumerate(rresults) if v.dvars['speedup'] > 1.0]

            # Colour the default value red, and the speedup > 1 values
            # green.
            for g in greenindexes:
                ax.get_children()[g].set_color('g')
            ax.get_children()[defaultindex].set_color('r')

            ax.set_xlabel('Parameter values for [C,R,S]')

            plt.gca().set_position((.1, .2, .85, .7)) # to make a bit of room for extra text

            plt.figtext(.02, .02,
                        ("Avg. {i:.1f} iterations, with 95% confidence intervals. "
                         "Avg. {t:.2f} ms execution time."
                         .format(i=meaniterations, t=meanruntime)))

            ax.set_ylabel('Speedup')
            ax.set_title(title)
            ax.set_xticks(xvals)
            ax.set_xticklabels(labels, rotation=90, ha='left')
            ax.get_xaxis().set_tick_params(labelsize=6)
            ax.axhline(y=1)

            plt.savefig(imgpath)
            print("Wrote '{0}'...".format(imgpath))

            #plt.show()
            plt.close()
